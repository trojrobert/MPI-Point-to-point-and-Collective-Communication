"""
Created on Wed Apr 25 05:19:18 2018
@author: John Robert
"""

from mpi4py import MPI
import numpy as np
from decimal import Decimal, ROUND_HALF_UP
import cv2

from matplotlib import pyplot as plt
from matplotlib import rcParams
import seaborn as sb

comm = MPI.COMM_WORLD 
rank=comm.Get_rank()
size = comm.Get_size()
root = 0
#To read the image into a matrix
#Load a greyscale image  
img = cv2.imread('images.jpg',0)

# img = cv2.imread('images.jpg',0)   load a color image in grayscale

#Print the matrix of the image
#print(img)


#Get the dimension of the matrix 
matrixGreySize = img.shape
#print("The size of matrix for greyscale image : {} \n".format(matrixGreySize))
NoRow = img.shape[0]
#print("The number of rows in the matrix is : {} \n".format(NoRow))

t_start = 0

#To find the frequencey of a number in an array 
def frequency(listofNumber):
    freqencyResult = {}
    for i in listofNumber:
            if i in freqencyResult:
                    freqencyResult[i] = freqencyResult.get(i)+1
            else:
                    freqencyResult[i] =1
    return freqencyResult


dataToScatterGrey = []

dataToComputeGrey = []

ProcessedFlattenData = []

totalFrequencyTableGrey={}
if rank == 0:
    t_start = MPI.Wtime()
    # No. of rows each process will work on
    dataSize4Worker = int(Decimal(NoRow / (size)).quantize(Decimal('1.'), rounding= ROUND_HALF_UP))
    #print("Size of data for each process is {} \n".format(dataSize4Worker))
     
    
    #Dividing  the initial matrix among the workers and sending it to them for computation
    for i in range(0,size):
        
        startSlice = dataSize4Worker * i
        
        #Checking if it is the last worker
        #Give remaining data to the last worker, in case all slice don't have equal size
        if i == size:
            endSlice = NoRow
        else:
            endSlice = startSlice + dataSize4Worker 
        
        #Arrage the slice of data in an array so it will be easy to scatter it 
        dataToComputeGrey.append(img[startSlice:endSlice, :])

#send sliced data to other workers for computation 
#print("DataToCompute for GreyScale: \n {} \n".format(dataToComputeGrey))
dataToScatterGrey = comm.scatter(dataToComputeGrey, root = 0)        

#Convert the slice of data into a array of one dimension array
flattenDataGrey = np.ravel(dataToScatterGrey)
#print("flattenData for Rank {}: \n {} \n".format(rank, flattenDataGrey))
#print (flattenDataGrey.shape)

#Get the frequency of 0 - 255 in the data sent 
processfrequencyTable = frequency(flattenDataGrey)
#print("Frequency distribution for rank process {} : \n {} \n".format(rank,processfrequencyTable))

#Combine the one dimension arrray generated by each process
ProcessedFlattenData.append(flattenDataGrey)

#Cominbine the frequency of 0 - 255 calculated by each process 
for i in processfrequencyTable:
        if i in totalFrequencyTableGrey:
            totalFrequencyTableGrey[i] = totalFrequencyTableGrey[i] + processfrequencyTable[i]
        else:
            totalFrequencyTableGrey[i] = processfrequencyTable[i]

#print("Total Frequency distribution : \n {} \n".format(totalFrequencyTableGrey))



if rank == 0:
    
    #To display an image in a window
    #cv2.imshow('image',img)
    
    #To display the image for a particular number of seconds
    #for a keyboard event 
    #cv2.waitKey(0)
    #TO close the windows of the images that were open
    #cv2.destroyAllWindows()
    #ProcessedFlattenData = np.ravel(ProcessedFlattenData)
    
        
    plt.hist(ProcessedFlattenData, 256, [0,256])
    plt.rcParams['figure.figsize'] = (15,15)
    sb.set_style ('whitegrid')
    plt.xlabel('Values of 0 - 255',fontsize=18)
    plt.ylabel('Frequency of occurrence',fontsize=18)
    plt.title('Histogram for gray scale picture',fontsize=18)
    #plt.legend(fontsize='x-large')
    #plt.show()
    
    
    #for key in sorted(totalFrequencyTable.iterkeys()):
        #print ("%s:   %s" % (key, totalFrequencyTable[key]))
    totalFrequencyTableGrey = dict(sorted(totalFrequencyTableGrey.items()))
    #print('value     Frequency')
    #for value, frequency in totalFrequencyTableGrey.items():
        #print('{}       {}'.format(value, frequency))

if rank == 0:
    t_diff = MPI.Wtime() - t_start
    print("Total time sent {} \n".format(t_diff))

